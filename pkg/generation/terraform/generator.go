package terraform

import (
	"fmt"
	"path/filepath"
	"sort"
	"strings"

	"github.com/BigChiefRick/chimera/pkg/generation"
)

// Generator implements the Generator interface for Terraform
type Generator struct{}

// NewGenerator creates a new Terraform generator
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate generates Terraform files from mapped resources
func (g *Generator) Generate(resources []generation.MappedResource, opts generation.GenerationOptions) ([]generation.GeneratedFile, error) {
	var files []generation.GeneratedFile

	// Generate provider configuration
	if opts.IncludeProvider {
		providerFile, err := g.generateProvider(resources, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to generate provider: %w", err)
		}
		files = append(files, providerFile)
	}

	// Generate main resource files
	if opts.SingleFile {
		mainFile, err := g.generateSingleFile(resources, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to generate main file: %w", err)
		}
		files = append(files, mainFile)
	} else if opts.OrganizeByType {
		typeFiles, err := g.generateByType(resources, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to generate by type: %w", err)
		}
		files = append(files, typeFiles...)
	} else {
		mainFile, err := g.generateMainFile(resources, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to generate main file: %w", err)
		}
		files = append(files, mainFile)
	}

	// Generate variables file
	variablesFile, err := g.generateVariables(resources, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to generate variables: %w", err)
	}
	files = append(files, variablesFile)

	// Generate outputs file
	outputsFile, err := g.generateOutputs(resources, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to generate outputs: %w", err)
	}
	files = append(files, outputsFile)

	// Generate modules if requested
	if opts.GenerateModules {
		moduleFiles, err := g.generateModules(resources, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to generate modules: %w", err)
		}
		files = append(files, moduleFiles...)
	}

	return files, nil
}

// generateProvider generates the provider configuration file
func (g *Generator) generateProvider(resources []generation.MappedResource, opts generation.GenerationOptions) (generation.GeneratedFile, error) {
	var content strings.Builder

	// Determine required providers
	providers := g.getRequiredProviders(resources)

	content.WriteString("terraform {\n")
	content.WriteString("  required_version = \">= 1.0\"\n")
	content.WriteString("  required_providers {\n")

	for provider, version := range providers {
		content.WriteString(fmt.Sprintf("    %s = {\n", provider))
		content.WriteString(fmt.Sprintf("      source  = \"hashicorp/%s\"\n", provider))
		content.WriteString(fmt.Sprintf("      version = \"%s\"\n", version))
		content.WriteString("    }\n")
	}

	content.WriteString("  }\n")
	content.WriteString("}\n\n")

	// Add provider configurations
	for provider := range providers {
		switch provider {
		case "aws":
			content.WriteString("provider \"aws\" {\n")
			content.WriteString("  region = var.aws_region\n")
			content.WriteString("}\n\n")
		case "azurerm":
			content.WriteString("provider \"azurerm\" {\n")
			content.WriteString("  features {}\n")
			content.WriteString("}\n\n")
		case "google":
			content.WriteString("provider \"google\" {\n")
			content.WriteString("  project = var.gcp_project\n")
			content.WriteString("  region  = var.gcp_region\n")
			content.WriteString("}\n\n")
		}
	}

	filePath := filepath.Join(opts.OutputPath, "providers.tf")
	if opts.OrganizeByType {
		filePath = filepath.Join(opts.OutputPath, "providers", "main.tf")
	}

	return generation.GeneratedFile{
		Path:         filePath,
		Content:      content.String(),
		Type:         generation.FileTypeProvider,
		Format:       generation.Terraform,
		Size:         int64(len(content.String())),
		ResourceCount: 0,
	}, nil
}

// generateSingleFile generates all resources in a single file
func (g *Generator) generateSingleFile(resources []generation.MappedResource, opts generation.GenerationOptions) (generation.GeneratedFile, error) {
	var content strings.Builder

	content.WriteString("# Infrastructure generated by Chimera\n")
	content.WriteString("# Generated on: " + opts.Timestamp + "\n\n")

	// Sort resources by type for better organization
	sort.Slice(resources, func(i, j int) bool {
		return resources[i].ResourceType < resources[j].ResourceType
	})

	currentType := ""
	for _, resource := range resources {
		if resource.ResourceType != currentType {
			if currentType != "" {
				content.WriteString("\n")
			}
			content.WriteString(fmt.Sprintf("# %s Resources\n", strings.Title(strings.ReplaceAll(resource.ResourceType, "_", " "))))
			currentType = resource.ResourceType
		}

		resourceHCL, err := g.generateResourceHCL(resource)
		if err != nil {
			return generation.GeneratedFile{}, fmt.Errorf("failed to generate HCL for resource %s: %w", resource.ResourceName, err)
		}
		content.WriteString(resourceHCL)
		content.WriteString("\n")
	}

	filePath := filepath.Join(opts.OutputPath, "main.tf")

	return generation.GeneratedFile{
		Path:         filePath,
		Content:      content.String(),
		Type:         generation.FileTypeMain,
		Format:       generation.Terraform,
		Size:         int64(len(content.String())),
		ResourceCount: len(resources),
	}, nil
}

// generateByType generates separate files for each resource type
func (g *Generator) generateByType(resources []generation.MappedResource, opts generation.GenerationOptions) ([]generation.GeneratedFile, error) {
	// Group resources by type
	resourcesByType := make(map[string][]generation.MappedResource)
	for _, resource := range resources {
		resourcesByType[resource.ResourceType] = append(resourcesByType[resource.ResourceType], resource)
	}

	var files []generation.GeneratedFile

	for resourceType, typeResources := range resourcesByType {
		var content strings.Builder

		content.WriteString(fmt.Sprintf("# %s Resources\n", strings.Title(strings.ReplaceAll(resourceType, "_", " "))))
		content.WriteString("# Generated by Chimera\n\n")

		for _, resource := range typeResources {
			resourceHCL, err := g.generateResourceHCL(resource)
			if err != nil {
				return nil, fmt.Errorf("failed to generate HCL for resource %s: %w", resource.ResourceName, err)
			}
			content.WriteString(resourceHCL)
			content.WriteString("\n")
		}

		fileName := fmt.Sprintf("%s.tf", strings.ReplaceAll(resourceType, "aws_", ""))
		filePath := filepath.Join(opts.OutputPath, fileName)

		file := generation.GeneratedFile{
			Path:         filePath,
			Content:      content.String(),
			Type:         generation.FileTypeMain,
			Format:       generation.Terraform,
			Size:         int64(len(content.String())),
			ResourceCount: len(typeResources),
		}

		files = append(files, file)
	}

	return files, nil
}

// generateMainFile generates the main.tf file
func (g *Generator) generateMainFile(resources []generation.MappedResource, opts generation.GenerationOptions) (generation.GeneratedFile, error) {
	var content strings.Builder

	content.WriteString("# Main Infrastructure Configuration\n")
	content.WriteString("# Generated by Chimera\n\n")

	// Sort resources by dependencies (basic dependency resolution)
	sortedResources := g.sortResourcesByDependencies(resources)

	for _, resource := range sortedResources {
		resourceHCL, err := g.generateResourceHCL(resource)
		if err != nil {
			return generation.GeneratedFile{}, fmt.Errorf("failed to generate HCL for resource %s: %w", resource.ResourceName, err)
		}
		content.WriteString(resourceHCL)
		content.WriteString("\n")
	}

	filePath := filepath.Join(opts.OutputPath, "main.tf")

	return generation.GeneratedFile{
		Path:         filePath,
		Content:      content.String(),
		Type:         generation.FileTypeMain,
		Format:       generation.Terraform,
		Size:         int64(len(content.String())),
		ResourceCount: len(resources),
	}, nil
}

// generateResourceHCL generates HCL for a single resource
func (g *Generator) generateResourceHCL(resource generation.MappedResource) (string, error) {
	var content strings.Builder

	content.WriteString(fmt.Sprintf("resource \"%s\" \"%s\" {\n", resource.ResourceType, resource.ResourceName))

	// Sort configuration keys for consistent output
	keys := make([]string, 0, len(resource.Configuration))
	for k := range resource.Configuration {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, key := range keys {
		value := resource.Configuration[key]
		hclValue, err := g.formatHCLValue(value, 1)
		if err != nil {
			return "", fmt.Errorf("failed to format value for key %s: %w", key, err)
		}
		content.WriteString(fmt.Sprintf("  %s = %s\n", key, hclValue))
	}

	content.WriteString("}\n")

	return content.String(), nil
}

// formatHCLValue formats a value for HCL output
func (g *Generator) formatHCLValue(value interface{}, indent int) (string, error) {
	switch v := value.(type) {
	case string:
		// Check if it's a Terraform interpolation
		if strings.HasPrefix(v, "${") && strings.HasSuffix(v, "}") {
			return v, nil
		}
		return fmt.Sprintf("\"%s\"", strings.ReplaceAll(v, "\"", "\\\"")), nil
	case int:
		return fmt.Sprintf("%d", v), nil
	case int32:
		return fmt.Sprintf("%d", v), nil
	case int64:
		return fmt.Sprintf("%d", v), nil
	case float32:
		return fmt.Sprintf("%.2f", v), nil
	case float64:
		return fmt.Sprintf("%.2f", v), nil
	case bool:
		return fmt.Sprintf("%t", v), nil
	case []interface{}:
		return g.formatHCLArray(v, indent)
	case []string:
		var items []interface{}
		for _, item := range v {
			items = append(items, item)
		}
		return g.formatHCLArray(items, indent)
	case map[string]interface{}:
		return g.formatHCLObject(v, indent)
	case map[string]string:
		obj := make(map[string]interface{})
		for k, v := range v {
			obj[k] = v
		}
		return g.formatHCLObject(obj, indent)
	default:
		return fmt.Sprintf("\"%v\"", v), nil
	}
}

// formatHCLArray formats an array for HCL output
func (g *Generator) formatHCLArray(values []interface{}, indent int) (string, error) {
	if len(values) == 0 {
		return "[]", nil
	}

	if len(values) == 1 {
		val, err := g.formatHCLValue(values[0], indent)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("[%s]", val), nil
	}

	var content strings.Builder
	content.WriteString("[\n")

	for i, value := range values {
		val, err := g.formatHCLValue(value, indent+1)
		if err != nil {
			return "", err
		}
		content.WriteString(strings.Repeat("  ", indent+1))
		content.WriteString(val)
		if i < len(values)-1 {
			content.WriteString(",")
		}
		content.WriteString("\n")
	}

	content.WriteString(strings.Repeat("  ", indent))
	content.WriteString("]")

	return content.String(), nil
}

// formatHCLObject formats an object for HCL output
func (g *Generator) formatHCLObject(obj map[string]interface{}, indent int) (string, error) {
	if len(obj) == 0 {
		return "{}", nil
	}

	var content strings.Builder
	content.WriteString("{\n")

	// Sort keys for consistent output
	keys := make([]string, 0, len(obj))
	for k := range obj {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for i, key := range keys {
		value := obj[key]
		val, err := g.formatHCLValue(value, indent+1)
		if err != nil {
			return "", err
		}
		content.WriteString(strings.Repeat("  ", indent+1))
		content.WriteString(fmt.Sprintf("%s = %s", key, val))
		if i < len(keys)-1 {
			content.WriteString(",")
		}
		content.WriteString("\n")
	}

	content.WriteString(strings.Repeat("  ", indent))
	content.WriteString("}")

	return content.String(), nil
}

// generateVariables generates the variables.tf file
func (g *Generator) generateVariables(resources []generation.MappedResource, opts generation.GenerationOptions) (generation.GeneratedFile, error) {
	var content strings.Builder

	content.WriteString("# Variables\n")
	content.WriteString("# Generated by Chimera\n\n")

	// Collect all variables
	variables := make(map[string]generation.Variable)
	
	// Add common variables
	variables["aws_region"] = generation.Variable{
		Type:        "string",
		Description: "AWS region for resources",
		Default:     "us-east-1",
	}

	// Add resource-specific variables
	for _, resource := range resources {
		for name, variable := range resource.Variables {
			// Prefix with resource name to avoid conflicts
			varName := fmt.Sprintf("%s_%s", resource.ResourceName, name)
			variables[varName] = variable
		}
	}

	// Sort variable names for consistent output
	varNames := make([]string, 0, len(variables))
	for name := range variables {
		varNames = append(varNames, name)
	}
	sort.Strings(varNames)

	for _, name := range varNames {
		variable := variables[name]
		content.WriteString(fmt.Sprintf("variable \"%s\" {\n", name))
		content.WriteString(fmt.Sprintf("  description = \"%s\"\n", variable.Description))
		content.WriteString(fmt.Sprintf("  type        = %s\n", variable.Type))
		
		if variable.Default != nil {
			defaultVal, err := g.formatHCLValue(variable.Default, 1)
			if err != nil {
				return generation.GeneratedFile{}, fmt.Errorf("failed to format default value for variable %s: %w", name, err)
			}
			content.WriteString(fmt.Sprintf("  default     = %s\n", defaultVal))
		}

		if variable.Sensitive {
			content.WriteString("  sensitive   = true\n")
		}

		content.WriteString("}\n\n")
	}

	filePath := filepath.Join(opts.OutputPath, "variables.tf")

	return generation.GeneratedFile{
		Path:         filePath,
		Content:      content.String(),
		Type:         generation.FileTypeVariables,
		Format:       generation.Terraform,
		Size:         int64(len(content.String())),
		ResourceCount: 0,
	}, nil
}

// generateOutputs generates the outputs.tf file
func (g *Generator) generateOutputs(resources []generation.MappedResource, opts generation.GenerationOptions) (generation.GeneratedFile, error) {
	var content strings.Builder

	content.WriteString("# Outputs\n")
	content.WriteString("# Generated by Chimera\n\n")

	// Collect all outputs
	outputs := make(map[string]generation.Output)

	for _, resource := range resources {
		for name, output := range resource.Outputs {
			// Prefix with resource name to avoid conflicts
			outputName := fmt.Sprintf("%s_%s", resource.ResourceName, name)
			outputs[outputName] = output
		}
	}

	// Sort output names for consistent output
	outputNames := make([]string, 0, len(outputs))
	for name := range outputs {
		outputNames = append(outputNames, name)
	}
	sort.Strings(outputNames)

	for _, name := range outputNames {
		output := outputs[name]
		content.WriteString(fmt.Sprintf("output \"%s\" {\n", name))
		content.WriteString(fmt.Sprintf("  description = \"%s\"\n", output.Description))
		content.WriteString(fmt.Sprintf("  value       = %s\n", output.Value))
		
		if output.Sensitive {
			content.WriteString("  sensitive   = true\n")
		}

		content.WriteString("}\n\n")
	}

	filePath := filepath.Join(opts.OutputPath, "outputs.tf")

	return generation.GeneratedFile{
		Path:         filePath,
		Content:      content.String(),
		Type:         generation.FileTypeOutputs,
		Format:       generation.Terraform,
		Size:         int64(len(content.String())),
		ResourceCount: 0,
	}, nil
}

// generateModules generates module files if requested
func (g *Generator) generateModules(resources []generation.MappedResource, opts generation.GenerationOptions) ([]generation.GeneratedFile, error) {
	var files []generation.GeneratedFile

	// Group resources by module structure
	modules := g.groupResourcesForModules(resources, opts.ModuleStructure)

	for moduleName, moduleResources := range modules {
		moduleFiles, err := g.generateModule(moduleName, moduleResources, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to generate module %s: %w", moduleName, err)
		}
		files = append(files, moduleFiles...)
	}

	return files, nil
}

// ValidateOutput validates generated Terraform files
func (g *Generator) ValidateOutput(files []generation.GeneratedFile) error {
	for _, file := range files {
		if err := g.validateTerraformSyntax(file.Content); err != nil {
			return fmt.Errorf("validation failed for file %s: %w", file.Path, err)
		}
	}
	return nil
}

// validateTerraformSyntax performs basic Terraform syntax validation
func (g *Generator) validateTerraformSyntax(content string) error {
	// Basic validation - check for balanced braces
	braceCount := 0
	lines := strings.Split(content, "\n")
	
	for lineNum, line := range lines {
		for _, char := range line {
			switch char {
			case '{':
				braceCount++
			case '}':
				braceCount--
				if braceCount < 0 {
					return fmt.Errorf("unmatched closing brace at line %d", lineNum+1)
				}
			}
		}
	}
	
	if braceCount != 0 {
		return fmt.Errorf("unmatched braces: %d unclosed", braceCount)
	}
	
	return nil
}

// groupResourcesForModules groups resources based on module structure
func (g *Generator) groupResourcesForModules(resources []generation.MappedResource, structure generation.ModuleStructure) map[string][]generation.MappedResource {
	modules := make(map[string][]generation.MappedResource)

	for _, resource := range resources {
		var moduleName string

		switch structure {
		case generation.ModuleByProvider:
			moduleName = string(resource.OriginalResource.Provider)
		case generation.ModuleByService:
			// Extract service from resource type (e.g., "aws_ec2" from "aws_instance")
			parts := strings.Split(resource.ResourceType, "_")
			if len(parts) >= 2 {
				moduleName = strings.Join(parts[:2], "_")
			} else {
				moduleName = resource.ResourceType
			}
		case generation.ModuleByRegion:
			moduleName = resource.OriginalResource.Region
		case generation.ModuleByResourceType:
			moduleName = resource.ResourceType
		default:
			moduleName = "main"
		}

		modules[moduleName] = append(modules[moduleName], resource)
	}

	return modules
}

// generateModule generates files for a single module
func (g *Generator) generateModule(moduleName string, resources []generation.MappedResource, opts generation.GenerationOptions) ([]generation.GeneratedFile, error) {
	var files []generation.GeneratedFile
	
	moduleDir := filepath.Join(opts.OutputPath, "modules", moduleName)

	// Generate module main file
	moduleOpts := opts
	moduleOpts.OutputPath = moduleDir
	moduleOpts.SingleFile = true

	mainFile, err := g.generateSingleFile(resources, moduleOpts)
	if err != nil {
		return nil, fmt.Errorf("failed to generate module main file: %w", err)
	}
	mainFile.Type = generation.FileTypeModule
	files = append(files, mainFile)

	// Generate module variables
	variablesFile, err := g.generateVariables(resources, moduleOpts)
	if err != nil {
		return nil, fmt.Errorf("failed to generate module variables: %w", err)
	}
	files = append(files, variablesFile)

	// Generate module outputs
	outputsFile, err := g.generateOutputs(resources, moduleOpts)
	if err != nil {
		return nil, fmt.Errorf("failed to generate module outputs: %w", err)
	}
	files = append(files, outputsFile)

	return files, nil
}

// Helper functions

// getRequiredProviders determines which providers are needed
func (g *Generator) getRequiredProviders(resources []generation.MappedResource) map[string]string {
	providers := make(map[string]string)

	for _, resource := range resources {
		switch {
		case strings.HasPrefix(resource.ResourceType, "aws_"):
			providers["aws"] = "~> 5.0"
		case strings.HasPrefix(resource.ResourceType, "azurerm_"):
			providers["azurerm"] = "~> 3.0"
		case strings.HasPrefix(resource.ResourceType, "google_"):
			providers["google"] = "~> 4.0"
		}
	}

	return providers
}

// sortResourcesByDependencies performs basic dependency sorting
func (g *Generator) sortResourcesByDependencies(resources []generation.MappedResource) []generation.MappedResource {
	// Create a simple dependency order
	typeOrder := map[string]int{
		"aws_vpc":              1,
		"aws_internet_gateway": 2,
		"aws_subnet":           3,
		"aws_route_table":      4,
		"aws_security_group":   5,
		"aws_key_pair":         6,
		"aws_instance":         7,
		"aws_ebs_volume":       8,
		"aws_eip":              9,
	}

	sort.Slice(resources, func(i, j int) bool {
		orderI, existsI := typeOrder[resources[i].ResourceType]
		orderJ, existsJ := typeOrder[resources[j].ResourceType]

		if existsI && existsJ {
			return orderI < orderJ
		}
		if existsI {
			return true
		}
		if existsJ {
			return false
		}
		return resources[i].ResourceType < resources[j].ResourceType
	})

	return resources
}
