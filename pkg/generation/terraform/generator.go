package terraform

import (
	"fmt"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/BigChiefRick/chimera/pkg/generation"
)

// Generator implements the Generator interface for Terraform
type Generator struct{}

// NewGenerator creates a new Terraform generator
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate generates Terraform files from mapped resources
func (g *Generator) Generate(resources []generation.MappedResource, opts generation.GenerationOptions) ([]generation.GeneratedFile, error) {
	var files []generation.GeneratedFile

	// Generate provider configuration
	if opts.IncludeProvider {
		providerFile, err := g.generateProvider(resources, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to generate provider: %w", err)
		}
		files = append(files, providerFile)
	}

	// Generate main resource files
	if opts.SingleFile {
		mainFile, err := g.generateSingleFile(resources, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to generate main file: %w", err)
		}
		files = append(files, mainFile)
	} else if opts.OrganizeByType {
		typeFiles, err := g.generateByType(resources, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to generate by type: %w", err)
		}
		files = append(files, typeFiles...)
	} else {
		mainFile, err := g.generateMainFile(resources, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to generate main file: %w", err)
		}
		files = append(files, mainFile)
	}

	// Generate variables file
	variablesFile, err := g.generateVariables(resources, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to generate variables: %w", err)
	}
	files = append(files, variablesFile)

	// Generate outputs file
	outputsFile, err := g.generateOutputs(resources, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to generate outputs: %w", err)
	}
	files = append(files, outputsFile)

	// Generate modules if requested
	if opts.GenerateModules {
		moduleFiles, err := g.generateModules(resources, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to generate modules: %w", err)
		}
		files = append(files, moduleFiles...)
	}

	return files, nil
}

// generateProvider generates the provider configuration file
func (g *Generator) generateProvider(resources []generation.MappedResource, opts generation.GenerationOptions) (generation.GeneratedFile, error) {
	var content strings.Builder

	content.WriteString("# Provider Configuration\n")
	content.WriteString("# Generated by Chimera\n\n")

	// Get required providers
	providers := g.getRequiredProviders(resources)

	// Generate terraform block with required providers
	content.WriteString("terraform {\n")
	content.WriteString("  required_providers {\n")

	for name, version := range providers {
		content.WriteString(fmt.Sprintf("    %s = {\n", name))
		content.WriteString(fmt.Sprintf("      source  = \"hashicorp/%s\"\n", name))
		content.WriteString(fmt.Sprintf("      version = \"%s\"\n", version))
		content.WriteString("    }\n")
	}

	content.WriteString("  }\n")
	content.WriteString("}\n\n")

	// Generate provider configurations
	for name := range providers {
		switch name {
		case "aws":
			content.WriteString("provider \"aws\" {\n")
			if opts.ProviderVersion != "" {
				content.WriteString(fmt.Sprintf("  # version = \"%s\"\n", opts.ProviderVersion))
			}
			content.WriteString("  # Configuration options\n")
			content.WriteString("  # region = var.aws_region\n")
			content.WriteString("}\n\n")
		case "azurerm":
			content.WriteString("provider \"azurerm\" {\n")
			content.WriteString("  features {}\n")
			content.WriteString("}\n\n")
		case "google":
			content.WriteString("provider \"google\" {\n")
			content.WriteString("  # project = var.gcp_project\n")
			content.WriteString("  # region  = var.gcp_region\n")
			content.WriteString("}\n\n")
		}
	}

	filePath := filepath.Join(opts.OutputPath, "providers.tf")

	return generation.GeneratedFile{
		Path:         filePath,
		Content:      content.String(),
		Type:         generation.FileTypeProvider,
		Format:       generation.Terraform,
		Size:         int64(len(content.String())),
		ResourceCount: 0,
	}, nil
}

// generateMainFile generates the main.tf file with all resources
func (g *Generator) generateMainFile(resources []generation.MappedResource, opts generation.GenerationOptions) (generation.GeneratedFile, error) {
	return g.generateSingleFile(resources, opts)
}

// generateSingleFile generates a single file with all resources
func (g *Generator) generateSingleFile(resources []generation.MappedResource, opts generation.GenerationOptions) (generation.GeneratedFile, error) {
	var content strings.Builder

	content.WriteString("# Infrastructure Resources\n")
	content.WriteString("# Generated by Chimera\n\n")

	// Sort resources by dependency order
	sortedResources := g.sortResourcesByDependencies(resources)

	for _, resource := range sortedResources {
		resourceHCL, err := g.GenerateResourceHCL(resource)
		if err != nil {
			return generation.GeneratedFile{}, fmt.Errorf("failed to generate HCL for resource %s: %w", resource.ResourceName, err)
		}
		content.WriteString(resourceHCL)
		content.WriteString("\n")
	}

	fileName := "main.tf"
	if opts.SingleFile {
		fileName = "main.tf"
	}

	filePath := filepath.Join(opts.OutputPath, fileName)

	return generation.GeneratedFile{
		Path:          filePath,
		Content:       content.String(),
		Type:          generation.FileTypeMain,
		Format:        generation.Terraform,
		Size:          int64(len(content.String())),
		ResourceCount: len(resources),
	}, nil
}

// generateByType generates separate files organized by resource type
func (g *Generator) generateByType(resources []generation.MappedResource, opts generation.GenerationOptions) ([]generation.GeneratedFile, error) {
	var files []generation.GeneratedFile

	// Group resources by type
	resourcesByType := make(map[string][]generation.MappedResource)
	for _, resource := range resources {
		resourcesByType[resource.ResourceType] = append(resourcesByType[resource.ResourceType], resource)
	}

	// Generate file for each type
	for resourceType, typeResources := range resourcesByType {
		var content strings.Builder

		content.WriteString(fmt.Sprintf("# %s Resources\n", resourceType))
		content.WriteString("# Generated by Chimera\n\n")

		// Sort resources by dependency order
		sortedResources := g.sortResourcesByDependencies(typeResources)

		for _, resource := range sortedResources {
			resourceHCL, err := g.GenerateResourceHCL(resource)
			if err != nil {
				return nil, fmt.Errorf("failed to generate HCL for resource %s: %w", resource.ResourceName, err)
			}
			content.WriteString(resourceHCL)
			content.WriteString("\n")
		}

		// Create filename from resource type
		fileName := strings.ReplaceAll(resourceType, "aws_", "") + ".tf"
		filePath := filepath.Join(opts.OutputPath, fileName)

		files = append(files, generation.GeneratedFile{
			Path:          filePath,
			Content:       content.String(),
			Type:          generation.FileTypeMain,
			Format:        generation.Terraform,
			Size:          int64(len(content.String())),
			ResourceCount: len(typeResources),
		})
	}

	return files, nil
}

// generateVariables generates the variables.tf file
func (g *Generator) generateVariables(resources []generation.MappedResource, opts generation.GenerationOptions) (generation.GeneratedFile, error) {
	var content strings.Builder

	content.WriteString("# Variables\n")
	content.WriteString("# Generated by Chimera\n\n")

	// Collect all variables
	variables := make(map[string]generation.Variable)

	for _, resource := range resources {
		for name, variable := range resource.Variables {
			variables[name] = variable
		}
	}

	// Sort variable names for consistent output
	varNames := make([]string, 0, len(variables))
	for name := range variables {
		varNames = append(varNames, name)
	}
	sort.Strings(varNames)

	for _, name := range varNames {
		variable := variables[name]
		content.WriteString(fmt.Sprintf("variable \"%s\" {\n", name))
		content.WriteString(fmt.Sprintf("  description = \"%s\"\n", variable.Description))
		content.WriteString(fmt.Sprintf("  type        = %s\n", variable.Type))
		
		if variable.Default != nil {
			content.WriteString(fmt.Sprintf("  default     = %v\n", variable.Default))
		}
		
		if variable.Sensitive {
			content.WriteString("  sensitive   = true\n")
		}

		content.WriteString("}\n\n")
	}

	filePath := filepath.Join(opts.OutputPath, "variables.tf")

	return generation.GeneratedFile{
		Path:         filePath,
		Content:      content.String(),
		Type:         generation.FileTypeVariables,
		Format:       generation.Terraform,
		Size:         int64(len(content.String())),
		ResourceCount: 0,
	}, nil
}

// generateOutputs generates the outputs.tf file
func (g *Generator) generateOutputs(resources []generation.MappedResource, opts generation.GenerationOptions) (generation.GeneratedFile, error) {
	var content strings.Builder

	content.WriteString("# Outputs\n")
	content.WriteString("# Generated by Chimera\n\n")

	// Collect all outputs
	outputs := make(map[string]generation.Output)

	for _, resource := range resources {
		for name, output := range resource.Outputs {
			// Prefix with resource name to avoid conflicts
			outputName := fmt.Sprintf("%s_%s", resource.ResourceName, name)
			outputs[outputName] = output
		}
	}

	// Sort output names for consistent output
	outputNames := make([]string, 0, len(outputs))
	for name := range outputs {
		outputNames = append(outputNames, name)
	}
	sort.Strings(outputNames)

	for _, name := range outputNames {
		output := outputs[name]
		content.WriteString(fmt.Sprintf("output \"%s\" {\n", name))
		content.WriteString(fmt.Sprintf("  description = \"%s\"\n", output.Description))
		content.WriteString(fmt.Sprintf("  value       = %s\n", output.Value))
		
		if output.Sensitive {
			content.WriteString("  sensitive   = true\n")
		}

		content.WriteString("}\n\n")
	}

	filePath := filepath.Join(opts.OutputPath, "outputs.tf")

	return generation.GeneratedFile{
		Path:         filePath,
		Content:      content.String(),
		Type:         generation.FileTypeOutputs,
		Format:       generation.Terraform,
		Size:         int64(len(content.String())),
		ResourceCount: 0,
	}, nil
}

// generateModules generates module files if requested
func (g *Generator) generateModules(resources []generation.MappedResource, opts generation.GenerationOptions) ([]generation.GeneratedFile, error) {
	var files []generation.GeneratedFile

	// Group resources by module structure
	modules := g.groupResourcesForModules(resources, opts.ModuleStructure)

	for moduleName, moduleResources := range modules {
		moduleFiles, err := g.generateModule(moduleName, moduleResources, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to generate module %s: %w", moduleName, err)
		}
		files = append(files, moduleFiles...)
	}

	return files, nil
}

// ValidateOutput validates generated Terraform files
func (g *Generator) ValidateOutput(files []generation.GeneratedFile) error {
	for _, file := range files {
		if err := g.validateTerraformSyntax(file.Content); err != nil {
			return fmt.Errorf("validation failed for file %s: %w", file.Path, err)
		}
	}
	return nil
}

// validateTerraformSyntax performs basic Terraform syntax validation
func (g *Generator) validateTerraformSyntax(content string) error {
	// Basic validation - check for balanced braces
	braceCount := 0
	lines := strings.Split(content, "\n")
	
	for lineNum, line := range lines {
		for _, char := range line {
			switch char {
			case '{':
				braceCount++
			case '}':
				braceCount--
				if braceCount < 0 {
					return fmt.Errorf("unmatched closing brace at line %d", lineNum+1)
				}
			}
		}
	}
	
	if braceCount != 0 {
		return fmt.Errorf("unmatched braces: %d unclosed", braceCount)
	}
	
	return nil
}

// GenerateModule generates a complete Terraform module with the provided configuration
func (g *Generator) GenerateModule(config generation.ModuleConfig) (map[string]string, error) {
	files := make(map[string]string)
	
	// Generate main.tf
	var mainContent strings.Builder
	mainContent.WriteString(fmt.Sprintf("# %s Module\n", config.Name))
	mainContent.WriteString(fmt.Sprintf("# Generated by Chimera on %s\n\n", time.Now().Format("2006-01-02 15:04:05")))
	
	// Add module resources if provided - NOTE: config.Resources is []TerraformResource, not []MappedResource
	if len(config.Resources) > 0 {
		for _, resource := range config.Resources {
			resourceHCL, err := g.GenerateResource(resource)
			if err != nil {
				return nil, fmt.Errorf("failed to generate HCL for resource %s: %w", resource.Name, err)
			}
			mainContent.WriteString(resourceHCL)
			mainContent.WriteString("\n")
		}
	}
	
	files["main.tf"] = mainContent.String()
	
	// Generate variables.tf from config.Variables
	var variablesContent strings.Builder
	variablesContent.WriteString("# Module Variables\n\n")
	
	// Sort variable names for consistent output
	varNames := make([]string, 0, len(config.Variables))
	for name := range config.Variables {
		varNames = append(varNames, name)
	}
	sort.Strings(varNames)
	
	for _, name := range varNames {
		variable := config.Variables[name]
		variablesContent.WriteString(fmt.Sprintf("variable \"%s\" {\n", name))
		variablesContent.WriteString(fmt.Sprintf("  description = \"%s\"\n", variable.Description))
		variablesContent.WriteString(fmt.Sprintf("  type        = %s\n", variable.Type))
		
		if variable.Default != nil {
			variablesContent.WriteString(fmt.Sprintf("  default     = %v\n", variable.Default))
		}
		
		if variable.Sensitive {
			variablesContent.WriteString("  sensitive   = true\n")
		}
		
		variablesContent.WriteString("}\n\n")
	}
	
	files["variables.tf"] = variablesContent.String()
	
	// Generate outputs.tf from config.Outputs
	var outputsContent strings.Builder
	outputsContent.WriteString("# Module Outputs\n\n")
	
	// Sort output names for consistent output
	outputNames := make([]string, 0, len(config.Outputs))
	for name := range config.Outputs {
		outputNames = append(outputNames, name)
	}
	sort.Strings(outputNames)
	
	for _, name := range outputNames {
		output := config.Outputs[name]
		outputsContent.WriteString(fmt.Sprintf("output \"%s\" {\n", name))
		outputsContent.WriteString(fmt.Sprintf("  description = \"%s\"\n", output.Description))
		outputsContent.WriteString(fmt.Sprintf("  value       = %s\n", output.Value))
		
		if output.Sensitive {
			outputsContent.WriteString("  sensitive   = true\n")
		}
		
		outputsContent.WriteString("}\n\n")
	}
	
	files["outputs.tf"] = outputsContent.String()
	
	// Generate versions.tf from config.Providers
	if len(config.Providers) > 0 {
		var versionsContent strings.Builder
		versionsContent.WriteString("terraform {\n")
		versionsContent.WriteString("  required_providers {\n")
		
		for _, provider := range config.Providers {
			versionsContent.WriteString(fmt.Sprintf("    %s = {\n", provider.Name))
			versionsContent.WriteString(fmt.Sprintf("      source  = \"%s\"\n", provider.Source))
			versionsContent.WriteString(fmt.Sprintf("      version = \"%s\"\n", provider.Version))
			versionsContent.WriteString("    }\n")
		}
		
		versionsContent.WriteString("  }\n")
		versionsContent.WriteString("}\n")
		
		files["versions.tf"] = versionsContent.String()
	}
	
	return files, nil
}

// GenerateResource generates Terraform HCL for a TerraformResource
func (g *Generator) GenerateResource(resource generation.TerraformResource) (string, error) {
	var content strings.Builder
	
	content.WriteString(fmt.Sprintf("resource \"%s\" \"%s\" {\n", resource.Type, resource.Name))
	
	// Add configuration attributes
	for key, value := range resource.Config {
		switch v := value.(type) {
		case string:
			// Check if it's a reference to another resource or variable
			if strings.Contains(v, ".") && (strings.HasPrefix(v, "var.") || strings.HasPrefix(v, "aws_") || strings.HasPrefix(v, "azurerm_") || strings.HasPrefix(v, "google_")) {
				content.WriteString(fmt.Sprintf("  %s = %s\n", key, v))
			} else {
				content.WriteString(fmt.Sprintf("  %s = \"%s\"\n", key, v))
			}
		case int, int64:
			content.WriteString(fmt.Sprintf("  %s = %v\n", key, v))
		case bool:
			content.WriteString(fmt.Sprintf("  %s = %t\n", key, v))
		case []interface{}:
			content.WriteString(fmt.Sprintf("  %s = %s\n", key, formatList(v)))
		case map[string]interface{}:
			content.WriteString(fmt.Sprintf("  %s = {\n", key))
			for subKey, subValue := range v {
				switch sv := subValue.(type) {
				case string:
					content.WriteString(fmt.Sprintf("    %s = \"%s\"\n", subKey, sv))
				default:
					content.WriteString(fmt.Sprintf("    %s = %v\n", subKey, sv))
				}
			}
			content.WriteString("  }\n")
		default:
			content.WriteString(fmt.Sprintf("  %s = \"%v\"\n", key, v))
		}
	}
	
	// Add dependencies if any
	if len(resource.Dependencies) > 0 {
		content.WriteString("  depends_on = [\n")
		for _, dep := range resource.Dependencies {
			content.WriteString(fmt.Sprintf("    %s,\n", dep))
		}
		content.WriteString("  ]\n")
	}
	
	content.WriteString("}\n")
	
	return content.String(), nil
}

// GenerateResourceHCL generates HCL for a MappedResource (interface requirement)
func (g *Generator) GenerateResourceHCL(resource generation.MappedResource) (string, error) {
	var content strings.Builder
	
	content.WriteString(fmt.Sprintf("resource \"%s\" \"%s\" {\n", resource.ResourceType, resource.ResourceName))
	
	// Add configuration attributes
	for key, value := range resource.Configuration {
		switch v := value.(type) {
		case string:
			// Check if it's a reference to another resource or variable
			if strings.Contains(v, ".") && (strings.HasPrefix(v, "var.") || strings.HasPrefix(v, "aws_") || strings.HasPrefix(v, "azurerm_") || strings.HasPrefix(v, "google_")) {
				content.WriteString(fmt.Sprintf("  %s = %s\n", key, v))
			} else {
				content.WriteString(fmt.Sprintf("  %s = \"%s\"\n", key, v))
			}
		case int, int64:
			content.WriteString(fmt.Sprintf("  %s = %v\n", key, v))
		case bool:
			content.WriteString(fmt.Sprintf("  %s = %t\n", key, v))
		case []interface{}:
			content.WriteString(fmt.Sprintf("  %s = %s\n", key, formatList(v)))
		case map[string]interface{}:
			content.WriteString(fmt.Sprintf("  %s = {\n", key))
			for subKey, subValue := range v {
				switch sv := subValue.(type) {
				case string:
					content.WriteString(fmt.Sprintf("    %s = \"%s\"\n", subKey, sv))
				default:
					content.WriteString(fmt.Sprintf("    %s = %v\n", subKey, sv))
				}
			}
			content.WriteString("  }\n")
		default:
			content.WriteString(fmt.Sprintf("  %s = \"%v\"\n", key, v))
		}
	}
	
	// Add dependencies if any
	if len(resource.Dependencies) > 0 {
		content.WriteString("  depends_on = [\n")
		for _, dep := range resource.Dependencies {
			content.WriteString(fmt.Sprintf("    %s,\n", dep))
		}
		content.WriteString("  ]\n")
	}
	
	content.WriteString("}\n")
	
	return content.String(), nil
}

// ValidateSyntax validates generated Terraform syntax (interface requirement)
func (g *Generator) ValidateSyntax(content string) error {
	return g.validateTerraformSyntax(content)
}

// GenerateProvider generates provider configuration block (interface requirement)
func (g *Generator) GenerateProvider(config generation.ProviderConfig) (string, error) {
	var content strings.Builder
	
	content.WriteString(fmt.Sprintf("provider \"%s\" {\n", config.Name))
	
	for key, value := range config.Config {
		switch v := value.(type) {
		case string:
			content.WriteString(fmt.Sprintf("  %s = \"%s\"\n", key, v))
		case int, int64:
			content.WriteString(fmt.Sprintf("  %s = %v\n", key, v))
		case bool:
			content.WriteString(fmt.Sprintf("  %s = %t\n", key, v))
		default:
			content.WriteString(fmt.Sprintf("  %s = \"%v\"\n", key, v))
		}
	}
	
	content.WriteString("}\n")
	
	return content.String(), nil
}

// GenerateVariables generates variables.tf content (interface requirement)
func (g *Generator) GenerateVariables(variables map[string]generation.Variable) (string, error) {
	var content strings.Builder
	
	content.WriteString("# Variables\n\n")
	
	// Sort variable names for consistent output
	varNames := make([]string, 0, len(variables))
	for name := range variables {
		varNames = append(varNames, name)
	}
	sort.Strings(varNames)
	
	for _, name := range varNames {
		variable := variables[name]
		content.WriteString(fmt.Sprintf("variable \"%s\" {\n", name))
		content.WriteString(fmt.Sprintf("  description = \"%s\"\n", variable.Description))
		content.WriteString(fmt.Sprintf("  type        = %s\n", variable.Type))
		
		if variable.Default != nil {
			content.WriteString(fmt.Sprintf("  default     = %v\n", variable.Default))
		}
		
		if variable.Sensitive {
			content.WriteString("  sensitive   = true\n")
		}
		
		content.WriteString("}\n\n")
	}
	
	return content.String(), nil
}

// GenerateOutputs generates outputs.tf content (interface requirement)
func (g *Generator) GenerateOutputs(outputs map[string]generation.Output) (string, error) {
	var content strings.Builder
	
	content.WriteString("# Outputs\n\n")
	
	// Sort output names for consistent output
	outputNames := make([]string, 0, len(outputs))
	for name := range outputs {
		outputNames = append(outputNames, name)
	}
	sort.Strings(outputNames)
	
	for _, name := range outputNames {
		output := outputs[name]
		content.WriteString(fmt.Sprintf("output \"%s\" {\n", name))
		content.WriteString(fmt.Sprintf("  description = \"%s\"\n", output.Description))
		content.WriteString(fmt.Sprintf("  value       = %s\n", output.Value))
		
		if output.Sensitive {
			content.WriteString("  sensitive   = true\n")
		}
		
		content.WriteString("}\n\n")
	}
	
	return content.String(), nil
}

// GenerateVersions generates versions.tf content (interface requirement)
func (g *Generator) GenerateVersions(providers []generation.ProviderConfig) (string, error) {
	var content strings.Builder
	
	content.WriteString("terraform {\n")
	content.WriteString("  required_providers {\n")
	
	for _, provider := range providers {
		content.WriteString(fmt.Sprintf("    %s = {\n", provider.Name))
		content.WriteString(fmt.Sprintf("      source  = \"%s\"\n", provider.Source))
		content.WriteString(fmt.Sprintf("      version = \"%s\"\n", provider.Version))
		content.WriteString("    }\n")
	}
	
	content.WriteString("  }\n")
	content.WriteString("}\n")
	
	return content.String(), nil
}

// formatList formats a list for Terraform HCL
func formatList(list []interface{}) string {
	var result strings.Builder
	result.WriteString("[")
	
	for i, item := range list {
		if i > 0 {
			result.WriteString(", ")
		}
		
		switch v := item.(type) {
		case string:
			result.WriteString(fmt.Sprintf("\"%s\"", v))
		default:
			result.WriteString(fmt.Sprintf("%v", v))
		}
	}
	
	result.WriteString("]")
	return result.String()
}

// groupResourcesForModules groups resources based on module structure
func (g *Generator) groupResourcesForModules(resources []generation.MappedResource, structure generation.ModuleStructure) map[string][]generation.MappedResource {
	modules := make(map[string][]generation.MappedResource)

	for _, resource := range resources {
		var moduleName string

		switch structure {
		case generation.ModuleByProvider:
			moduleName = string(resource.OriginalResource.Provider)
		case generation.ModuleByService:
			// Extract service from resource type (e.g., "aws_ec2" from "aws_instance")
			parts := strings.Split(resource.ResourceType, "_")
			if len(parts) >= 2 {
				moduleName = strings.Join(parts[:2], "_")
			} else {
				moduleName = resource.ResourceType
			}
		case generation.ModuleByRegion:
			moduleName = resource.OriginalResource.Region
		case generation.ModuleByResourceType:
			moduleName = resource.ResourceType
		default:
			moduleName = "main"
		}

		modules[moduleName] = append(modules[moduleName], resource)
	}

	return modules
}

// generateModule generates files for a single module
func (g *Generator) generateModule(moduleName string, resources []generation.MappedResource, opts generation.GenerationOptions) ([]generation.GeneratedFile, error) {
	var files []generation.GeneratedFile
	
	moduleDir := filepath.Join(opts.OutputPath, "modules", moduleName)

	// Generate module main file
	moduleOpts := opts
	moduleOpts.OutputPath = moduleDir
	moduleOpts.SingleFile = true

	mainFile, err := g.generateSingleFile(resources, moduleOpts)
	if err != nil {
		return nil, fmt.Errorf("failed to generate module main file: %w", err)
	}
	mainFile.Type = generation.FileTypeModule
	files = append(files, mainFile)

	// Generate module variables
	variablesFile, err := g.generateVariables(resources, moduleOpts)
	if err != nil {
		return nil, fmt.Errorf("failed to generate module variables: %w", err)
	}
	files = append(files, variablesFile)

	// Generate module outputs
	outputsFile, err := g.generateOutputs(resources, moduleOpts)
	if err != nil {
		return nil, fmt.Errorf("failed to generate module outputs: %w", err)
	}
	files = append(files, outputsFile)

	return files, nil
}

// Helper functions

// getRequiredProviders determines which providers are needed
func (g *Generator) getRequiredProviders(resources []generation.MappedResource) map[string]string {
	providers := make(map[string]string)

	for _, resource := range resources {
		switch {
		case strings.HasPrefix(resource.ResourceType, "aws_"):
			providers["aws"] = "~> 5.0"
		case strings.HasPrefix(resource.ResourceType, "azurerm_"):
			providers["azurerm"] = "~> 3.0"
		case strings.HasPrefix(resource.ResourceType, "google_"):
			providers["google"] = "~> 4.0"
		}
	}

	return providers
}

// sortResourcesByDependencies performs basic dependency sorting
func (g *Generator) sortResourcesByDependencies(resources []generation.MappedResource) []generation.MappedResource {
	// Create a simple dependency order
	typeOrder := map[string]int{
		"aws_vpc":              1,
		"aws_internet_gateway": 2,
		"aws_subnet":           3,
		"aws_route_table":      4,
		"aws_security_group":   5,
		"aws_key_pair":         6,
		"aws_instance":         7,
		"aws_ebs_volume":       8,
		"aws_eip":              9,
	}

	sort.Slice(resources, func(i, j int) bool {
		orderI, existsI := typeOrder[resources[i].ResourceType]
		orderJ, existsJ := typeOrder[resources[j].ResourceType]

		if existsI && existsJ {
			return orderI < orderJ
		}
		if existsI {
			return true
		}
		if existsJ {
			return false
		}
		return resources[i].ResourceType < resources[j].ResourceType
	})

	return resources
}
